# Name-based + new position-based destructuring

* **Type**: Design proposal
* **Author**: Anastasiia Pikalova, Mikhail Zarechenskii, Alejandro Serrano
* **Contributors**: Marat Akhin, Aleksandra Arsenteva, Nikita Bobko, Roman Efremov, Roman Venediktov
* **Discussion**: [KEEP-438](https://github.com/Kotlin/KEEP/discussions/438)
* **Status**: Public discussion
* **Related YouTrack issue**: [KT-19627](https://youtrack.jetbrains.com/issue/KT-19627/Object-name-based-destructuring)

## Abstract

We propose a new form of **destructuring** based on **names** instead of positions.
In addition, we propose new syntax for **position**-based destructuring.

## Table of contents

* [Abstract](#abstract)
* [Table of contents](#table-of-contents)
* [Motivation](#motivation)
  * [General problems](#general-problems)
  * [Problems with data classes](#problems-with-data-classes)
  * [The role of position-based destructuring](#the-role-of-position-based-destructuring)
  * [Out of scope](#out-of-scope)
* [Proposed solution](#proposed-solution)
  * [New position-based destructuring](#new-position-based-destructuring)
  * [Migration plan](#migration-plan)
* [Technical details](#technical-details)
* [Potential extensions](#potential-extensions)

## Motivation

Kotlin supports [destructuring declarations](https://kotlinlang.org/spec/operator-overloading.html#destructuring-declarations)
as a syntactically-lightweight way to obtain several values from the same source.

```kotlin
val (name, age) = person
```

Destructuring declarations are desugared to call to `componentN` functions,
where `N` stands for the place in the declaration itself. For that reason
we refer to this type of destructuring as **position-based** or **positional**.

```kotlin
val $tmp = person
val name = $tmp.component1()
val age = $tmp.component2()
```

These `componentN` function may be declared on any type, and even as extension
functions. However, the main source of them are
[data classes](https://kotlinlang.org/spec/declarations.html#data-class-declaration),
for which the compiler generates `componentN` functions for each of the 
primary constructor properties.

```kotlin
class Person(val name: String, val age: Int) {
    // these functions are generated by the compiler
    operator fun component1(): String = name
    operator fun component2(): Int = age
}
```

After these years, we recognize that position-based destructuring, albeit
convenient in many cases, comes with several important problems. Our goal
in this KEEP is providing a better alternative in the form of **name-based**
destructuring, that is, destructuring in which the name of the properties,
and not their place in the declaration, decide which value to extract.

### General problems

Some of the problems with position-based destructuring apply regardless of
the class to destructure. Others relate to the automatic generation in data
classes; those are treated in a separate section.

**Loss of semantic clarity.** Since the name of the property doesn't play a role
in position-based destructuring, this opens the door to potential confusion.
This is especially problematic when the types of several properties coincide.

```kotlin
data class Person(val name: String, val address: String) 

// 'city' refers to 'name', 'name' refers to 'address'
val (city, name) = UserData("name", "Amsterdam")
```

**Difficult extensibility.** It is inconvenient to provide additional members
that can be destructured using position-based syntax. Although on the paper
you can always define a `componentN` extension function, even figuring out
what `N` should be is difficult.

### Problems with data classes

**Binary compatibility.** In theory, adding a new property to an existing class
is a binary-compatible change (to be fully precise, only if you provide a
constructor setting a default value). However, the coupling between position
and primary constructor in data classes means that adding field may become
binary-breaking if the order is not respected.

```kotlin
// 'age' is added in the middle
data class Person(val name: String, val age: Int?, val address: String) {
    // we have a secondary constructor
    constructor(name: String, address: String) : this(name, null, address)

    // alas, 'component2' changes from 'String' to 'Int?'
    operator fun component1() = this.name
    operator fun component2() = this.age
    operator fun component3() = this.address
}
```

**Accidental changes.** Following with the case above, not only binary
compatibility breaks, _source_ compatibility also. This is because in a
destructuring declaration,

```kotlin
val (name, address) = person
```

now the second position refers to `age`. Since this has a different type,
we may expect broken code afterward.

**Private properties.** If a property is defined as `private`, the corresponding
`componentN` function is also private. This guarantees that the value is not
leaked, but has the bad consequence that after that property no more can be
destructured. This is because position-based destructuring requires access to
**all** `componentN` functions in order.

```kotlin
data class Person(val name: String, private val age: Int?, val address: String) {
    val underage: Boolean = age < 21
}

fun foo(p: Person) {
    // destructure results in an error due to 'age' being private
    val (name1, age1, address1) = p // error: INVISIBLE_MEMBER

    // skipping the private property doesn't work either
    val (name2, _, address2) = p  // still error: INVISIBLE_MEMBER
}
```

### The role of position-based destructuring

The discussion above doesn't mean that we should simply remove position-based
destructuring. There are a few types with an inherent notion of _ordering_
between their elements, such as:

* Ordered collection types such as `List`,
* Unnamed tuples, such as `Pair` and `Triple`.

### Out of scope

This KEEP does not change the current behavior of
[data classes](https://kotlinlang.org/spec/declarations.html#data-class-declaration).
In particular, `componentN` functions are still generated; better control over
those declarations should be part of a separate KEEP document.

## Proposed solution

We propose to introduce a new form of **name-based destructuring**, in which
properties are matched by name. In case the name of the property to be accessed
and the name of the newly-declared variable doesn't coincide, we provide
**renaming** syntax. In fact, shorter syntax `val x` can be though of as 
shorthand for writing the extended `val x = x`.

```kotlin
(val age, val name = fullName) = person

// desugars to
val $tmp = person
val age = $tmp.age
val name = $tmp.fullName
```

There are quite some design choices to be made on top of that basic concept.

**Syntax.** On giving syntax for a new form of destructuring we find ourselves
in a conundrum: the syntax should be similar enough to the existing one to
be recognizable and accepted by the Kotlin community, but different enough
from existing syntax to avoid confusion.

The proposed syntax makes it clear that we are defining new variables since
it uses `val`, and reads quite naturally in the case of renaming. 
There is indeed some repetition in `val`, but this opens the door to using 'var'.

> [!IMPORTANT]
> Because of technical issues it will not be possible to write annotations
> before each of the elements. Details are explained below.

**Renaming.** In this proposal we restrict what may appear after `=` in
renaming to **simple identifiers**. In principle it is possible to allow
more complex expressions, but at that point it feels that using different
lines for each declaration results in more readable code.

One potential **risk** of the current syntax is the added difficulty for
tooling to provide completion. While in the middle of writing,

```kotlin
(val name = <caret>)
```

it is impossible to know what should appear there until the expression is
written, but that happens much later. To mitigate this risks tooling may
provide some sort of template for which the expression in the right-hand
side is written before, and then the caret moves inside the parentheses.

**Available properties.** There are three possibilities for the properties
that may be destructured with the syntax.

1. Only primary constructor properties,
2. Only member properties,
3. Any property, including extensions.

The first level more closely resembles pattern matching like those available
for records in [Java](https://openjdk.org/jeps/440)
and [Haskell](https://www.haskell.org/onlinereport/haskell2010/haskellch3.html#x8-490003.15).
However, it severely restricts abstractions, since destructuring is never
available for properties in interfaces.

The second and third option lead to a simpler model, in which name-based
destructuring can be thought as a shorthand for a sequence of simple
declarations.
The difference between the second and third option is whether we want the
author of the class to have full control over what is exposed using name-based
destructuring or not.

**Lambdas and loops**. There is another place in which destructuring is
available, namely in the declaration of parameters for loops and lambdas.
Name-based destructuring is also available in those scenarios.

```kotlin
for ((val age, val name = fullName) in people) { ... }

{ (val argumentTypes, val returnType) -> ... }
```

### New position-based destructuring

As discussed above, position-based destructuring still has a role in Kotlin.
We propose to introduce new syntax that complements the one for name-based,
and at the same type more distinctively remembers of "position". 
For the latter point, reflecting the syntax of
[collection literals](https://github.com/Kotlin/KEEP/blob/bobko/collection-literals/proposals/collection-literals.md)
seems the best option.

```kotlin
val pair = Pair(3, "hello")
[val number, val string] = pair
```

**Short syntax.** We also provide a counterpart of the current destructuring
syntax but using the square brackets. This allows developer to continue using
position-based destructuring when needed, without incurring in longer code.

```kotlin
val [number, string] = pair
```

This syntax is quite useful in combination with loops and lambdas, where
directly destructuring a (key-value) pair is quite common.

```kotlin
for ([key, value] in mapOfCoolThings) { ... }
```

**No per-type destructuring.** One potential design choice is to make the
current syntax refer to name-based or position-based destructuring based on some
modifier or annotation on the type. However, this design comes with a few
problems:

- It is not clear at _use site_ which kind of destructuring is being applied,
- It doesn't play well with _generics_. For example, if the developer writes
  `val (age, name) = person` where `person` has some interface type,
  should the compiler use name- or position-based destructuring depending on the
  chosen subclass?

### Migration plan

This KEEP wouldn't be complete without an answer to the question of how these
new forms of destructuring are going to be alongside the existing ones.
We definitely need a gradual rollout of this feature.

**The end goal.** To understand the migration plan, we need to define the
ideal design we want once the migration ends. In that situation we would have
_four_ modes of syntax: name- versus position-based, and short versus full.

```kotlin
val (fullName, age) = person             // name, short
(val name = fullName, val age) = person  // name, full

val [number, string] = pair              // position, short
[val number, val string] = pair          // position, full
```

Only the full syntax allows renaming and (potentially) declaration of `var`, 
annotations, and any other modifiers.

**The intersection**. Note that in the _end goal_ scenario, name-based
short syntax and the current position-based syntax coincide when the
properties come from the primary constructor of a data class, and appear
in the same order and with the same name. That is, those destructuring
declarations require _no_ change even if we flip the meaning of the syntax.
This realization is important in the migration plan.

> [!IMPORTANT]
> The phases below are not tied to a specific Kotlin version or timeline.
> Compilers are expected to provide a flag for opting into the _Phase 3_ behavior.

**Phase 1.** At this phase we want to raise _awareness_ of the new feature.

- Introduce full form name-based destructuring, and both short and full forms
  of the new position-based destructuring. This syntax does not conflict with
  any other in Kotlin.
- Keep `val (x, y) = e` as position-based destructuring.
- Make tooling nudge developers into switching to name-based destructuring
  in those cases in which the flip would change semantics.

If possible, tooling should provide also automatic migration to the new syntax:

- For data classes using auto-generated `componentN` functions, move into
  name-based destructuring, potentially with renaming.
- For other usages, move into the new position-based destructuring syntax.

Those rules may be tweaked slightly for `Pair`, `Tuple`, key-value maps, and
other types for which position-based destructuring makes more sense.

**Phase 2.** At this phase we prepare the community for the flip. The nudge
to move to the new syntax moves from tooling to the compiler itself, which
**warns** for any potential change in behavior.

**Phase 3.** At this phase `val (x, y) = e` becomes syntax for name-based
destructuring.

- As a result, lambdas and loops also use the short syntax, 
  `{ (x, y) -> ...}`, for name-based destructuring.

## Technical details

**Grammar**. The [grammar](https://kotlinlang.org/spec/syntax-and-grammar.html#syntax-grammar)
is updated as follows. In both `multiParenVariableDeclaration` and
`fullMultiParenVariableDeclaration` the use of the identifier 
[`_` for unused variables](https://github.com/Kotlin/KEEP/blob/underscore-for-unused-local/proposals/underscores-for-local-variables.md)
is forbidden, except when using renaming.

> [!NOTE]
> The use of `Paren` in the production rule means "between parentheses".
> We refrain from using "name-based" here, because the same syntax is going
> to be used for position- and name-based destructuring at different phases,
> as described in the [migration plan](#migration-plan).

_Allow new syntax in properties, loops, and lambdas_

```diff

  declaration:
      ...
    | functionDeclaration
    | propertyDeclaration
+   | fullMultiPropertyDeclaration
    | typeAlias

+ fullMultiPropertyDeclaration
+   fullMultiVariableDeclaration
+   {NL} '=' {NL} expression
+   [{NL} ';'] {NL}

  forStatement:
-   (variableDeclaration | multiVariableDeclaration)
+   (variableDeclaration | multiVariableDeclaration | fullMultiVariableDeclaration)

  lambdaParameter:
      variableDeclaration
    | (multiVariableDeclaration [{NL} ':' {NL} type])
+   | (fullMultiVariableDeclaration [{NL} ':' {NL} type])
```

_Introduce new position-based short syntax_

```diff
+ multiVariableDeclaration
+     multiParenVariableDeclaration
+   | multiPositionalVariableDeclaration

- multiVariableDeclaration:
+ multiParenVariableDeclaration:
    # same as 'multiVariableDeclaration' before

+ multiPositionalVariableDeclaration:
+   # same as 'multiParenVariableDeclaration' but using '[' and ']'
```

_Introduce new full-syntax, both name- and position-based_

```diff
+ fullMultiVariableDeclaration:
+     fullMultiParenVariableDeclaration
+   | fullMultiPositionalVariableDeclaration

+ fullMultiParenVariableDeclaration:
+   '('
+   {NL}
+   fullVariableDeclarationWithRenaming
+   {{NL} ',' {NL} fullVariableDeclarationWithRenaming}
+   [{NL} ',']
+   {NL}
+   ')'

+ fullMultiPositionalVariableDeclaration:
+   '['
+   {NL}
+   fullVariableDeclaration
+   {{NL} ',' {NL} fullVariableDeclaration}
+   [{NL} ',']
+   {NL}
+   ']'

+ fullVariableDeclaration:
+   'val'   # ('val' | 'var') if mutable variables are allowed
+   {NL} simpleIdentifier [{NL} ':' {NL} type]

+ fullVariableDeclarationWithRenaming:
+   fullVariableDeclaration [{NL} ('=' {NL} simpleIdentifier)]
```

**Disambiguation**. One important restriction of this design is that no
modifiers (including annotations) may appear before the `val` (or
potentially, `var`) in the full-form. This is needed because the parser
must be able to disambiguate those forms from other similar ones in the grammar:

- the full-form of name-based destructuring starts in the same
  way that a _parenthesized expression_, 
- the full-form of the new position-based destructuring conflicts with 
  _indexing expressions_.

With the restriction, when the parser sees `(` or `[`, it only needs **one**
token of lookahead to decide which parsing rule ought to be applied.

It is possible to extend this rule to modifiers that may not appear in front
of an expression (like `public`). This rejects annotations, since they may
appear in front of an expression too. We would need unbounded lookahead to
decide which rule to apply, which would heavily impact parsing performance.

**Translation**. The compiler should treat name-based destructuring as a
sequence of property accesses. In general, a name-based destructuring
declaration has the following form, where declarations without renaming
`val x` are previously turned into `val x = x`.

```kotlin
(val x1 = p1, ... val xN = pN) = e
````

This general form should be translated as follows.

```kotlin
val $tmp = e
val x1 = $tmp.p1
...
val xN = $tmp.pN
```

This informs the expected behavior of the code, in particular with respect
to the _order_ in which operations happen.
For example, if accessing `p1` stops computation, then all the rest of
declarations would be marked as inaccessible code.

The translation of the new syntax for position-based destructuring follows
the same rules of
[current syntax](https://kotlinlang.org/spec/operator-overloading.html#destructuring-declarations).

## Potential extensions

**Renaming**. We've discussed above that we restrict renaming to simple
identifiers because otherwise readability suffers. There are however a few
extensions which are really borderline, and may be considered in the future.

```kotlin
// nested access
(val city = address.city, val country = address.country) = person

// Elvis operators
(val age, val name = fullName ?: "unknown") = person

// indexing expressions
(val name = ["name"]) = jsonPerson
```

**Assignment**. This proposal only defines destructuring to _declare_
new variables. It could be possible to extend the syntax to also _assign_
new values to existing variables.

```kotlin
var name = "unknown"
(name, val age) = person
```

However, such syntax raises some questions, like whether it is possible to
mix declaration and assignment. Since destructuring has only been available
for declaration in Kotlin up to this point, we think respecting that decision
is the best way to go.

**Pattern matching.** The proposed syntax has been carefully chosen to keep
the door open to future pattern matching facilities.
[Java](https://openjdk.org/jeps/440) uses similar syntax, but using a type
annotation or `var`. 

```kotlin
person is Person (val name, val age)
```

Note that regardless of the chosen syntax, any pattern matching facility
in Kotlin needs to distinguish between the cases "match against the `name`
variable" and "create a new `name` variable", so a token like `val` would
be required.
